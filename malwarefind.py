import os
import re
import sys
import csv
import hashlib
from colorama import Fore, Back, Style, init
from replacer import check_and_replace
import time 
from get_hashes import add_hash_to_whitelist
from tkinter import Tk, filedialog
import subprocess

init(autoreset=True)

# Load the whitelist from a CSV file
def load_whitelist_from_csv(csv_file):
    whitelist = set()  # Use a set to store only hashes
    try:
        with open(csv_file, mode='r') as file:
            reader = csv.DictReader(file)  # Use DictReader to handle headers
            for row in reader:
                file_hash = row['SHA-256 Hash']  # Only take the hash from the CSV
                whitelist.add(file_hash)
    except FileNotFoundError:
        print(Fore.RED + f"Error: CSV file '{csv_file}' not found.")
    return whitelist


# Define the regex pattern for hex escape sequences (longer sequences)
hex_escape_pattern = r"(\\x[0-9a-fA-F]{2}){4,}"  # Sequences with at least 4 hex chars

# Define the regex pattern for string.char() with 4 ASCII numbers (case-insensitive)
regex_pattern = r"string\.char\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)"

# Define the regex pattern for table.concat({...})
table_concat_pattern = r"table\.concat\(\{('.*?')\}\)"

# Define Lua malware-related patterns (case-insensitive) and their descriptions
lua_malware_patterns = [
    (r"http.request\(", "HTTP request to external servers (potential C2 communication)."),
    (r"os\.execute\(", "Executing OS commands, which can be dangerous if abused."),
    (r"base64\.decode\(", "Decoding base64 strings, often used to hide payloads."),
    (r"string\.gsub\(", "Often used in string obfuscation."),
    (r"string\.reverse\(", "Reversing strings, typically part of obfuscation."),
    (r"for _, _ in pairs\(", "Iterating over table entries, possibly part of obfuscated code."),
    (r"table.concat", "Concatenating table values, possibly forming hidden strings."),
    (r"cron:runat", "Cron job execution, which can be used to trigger malicious code."),
    (r"_G\[.*\]\(", "Dynamic global access, which is suspicious as it allows manipulation of global environment."),
]

# Define JavaScript malware-related patterns (case-insensitive) and their descriptions
js_malware_patterns = [
    (r"eval\(", "Use of eval for dynamic code execution, often used in obfuscated malware."),
    (r"atob\(", "Decoding base64 encoded strings, common in obfuscation techniques."),
    (r"setTimeout\(", "setTimeout with string, commonly used to delay execution of obfuscated code."),
    (r"document\.write\(", "Document write, which can be used for malicious script injections."),
    (r"fetch\(", "Making network requests using fetch, can be used for data exfiltration or C2 communication."),
    (r"XMLHttpRequest\(", "Making network requests using XMLHttpRequest, potentially C2 communication.")
]

# Add the specific hex patterns
specific_hex_patterns = [
    (r"\\x68\\x65\\x6c\\x70\\x43\\x6f\\x64\\x65", "Hex pattern that corresponds to 'helpCode'."),
    (r"\\x61\\x73\\x73\\x65\\x72\\x74", "Hex pattern that corresponds to 'assert'."),
    (r"\\x52\\x65\\x67\\x69\\x73\\x74\\x65\\x72\\x4e\\x65\\x74\\x45\\x76\\x65\\x6e\\x74", "Hex pattern that corresponds to 'RegisterNetEvent'."),
    (r"\\x50\\x65\\x72\\x66\\x6f\\x72\\x6d\\x48\\x74\\x74\\x70\\x52\\x65\\x71\\x75\\x65\\x73\\x74", "Hex pattern that corresponds to 'PerformHttpRequest'."),
    (r"\\x6c\\x6f\\x61\\x64", "Hex pattern that corresponds to 'load' function."),
]

# Define multiple string-based patterns for different 'url' constructions (case-insensitive)
string_patterns = [
    ("local url = x1..x2..x3..x4..x5..x6", "Obfuscated URL construction."),
    ("local url = x7..x8..x9..x10..x11..x12", "Another example of obfuscated URL construction."),
    ("local url = y1..y2..y3..y4..y5..y6", "Another obfuscated URL construction pattern."),
    ("local task = _G[table.concat({'P', 'erf', 'ormH', 'ttpR', 'eque', 'st'})]", "Obfuscated method to perform HTTP requests."),
    (r"http.*?://.*?/.*?php\?to=.*", "Suspicious PHP URL pattern possibly used for C2 communication."),
]

# Whitelisted patterns to skip common false positives
whitelisted_patterns = [
    r"\\x3c!--",  # HTML comments in Font Awesome
    r"\\x20",     # Space character in minified files
    r"\\x7f",     # Common escape in jQuery
    r"\\xA0",     # Non-breaking space in HTML
]

# Keywords that make the hex suspicious
suspicious_keywords = [
    r"eval\(", r"decode\(", r"unescape\(", r"window\.location", r"document\.write"
]

# Excluded file extensions (to reduce false positives)
excluded_extensions = ['.min.js', '.js', '.css', '.min.css']

# Whitelisted files
whitelisted_files = ['malwarefind.py', 'get_hashes-dowloader.py', 'get_hashes.py', 'replacer.py', 'safe_files.csv', 'whitelisted_js_files.csv']

# Folders to exclude from the search
excluded_folders = ['[standalone]', '[cfx-default]', 'ox_lib', '[GUARD]', 'node_modules', '__pycache__', 'NTS_FILES_SINISTRO_RP']

whitelisted_paths = {}
safe_files_csv = 'safe_files.csv'


def load_safe_files():
    """Load whitelisted file paths and hashes from 'safe_files.csv'."""
    if os.path.exists(safe_files_csv):
        with open(safe_files_csv, mode='r') as file:
            reader = csv.reader(file)
            for row in reader:
                if len(row) == 2:
                    file_path, file_hash = row
                    whitelisted_paths[file_path] = file_hash
        print(Fore.GREEN + f"Loaded {len(whitelisted_paths)} whitelisted files from 'safe_files.csv'.")



def add_filepath_to_whitelist(file_path):
    """Add file path to the whitelist and save it to 'safe_files.csv'."""
    if file_path not in whitelisted_paths:
        file_hash = get_file_hash(file_path)
        whitelisted_paths[file_path] = file_hash
        print(Fore.GREEN + f"The file path '{file_path}' has been added to the whitelist.")
        
        # Save the file path and hash to 'safe_files.csv'
        with open(safe_files_csv, mode='a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([file_path, file_hash])  # Save file path and hash
        print(Fore.GREEN + f"The file path '{file_path}' and its hash have been saved to 'safe_files.csv'.")


def handle_safe_file(file_path):
    confirm_safe_response = input(Fore.WHITE + Back.RED + Style.BRIGHT+  f"Are you sure you want to mark this file as safe? This means it will not be scanned in the future. (y/n): ").strip().lower()
    if confirm_safe_response == 'y':
        print(Fore.GREEN + "The file will be marked as safe and will not be scanned in future checks.")
        add_filepath_to_whitelist(file_path)
        add_hash_to_whitelist(file_path)
    else:
        print(Fore.YELLOW + "The file will not be marked as safe.")


def get_file_hash(file_path):
    """Returns the SHA-256 hash of a file, preserving header comments and removing inline comments."""
    sha256_hash = hashlib.sha256()
    
    with open(file_path, "rb") as f:
        content = f.read()
        normalized_content = content.replace(b'\r\n', b'\n')

        # Decode to string for further normalization
        normalized_content_str = normalized_content.decode('utf-8', errors='ignore')

        # Preserve the header comments (if they start with /* and contain v)
        # and remove inline comments (// or /* ... */) only from the rest of the content
        header_regex = r'/\*\!(.*?)(\n|\r\n)'
        header_match = re.search(header_regex, normalized_content_str)

        if header_match:
            # Get the header
            header = header_match.group(0)
            # Remove inline comments from the rest of the content
            content_without_inline_comments = re.sub(r'//.*|/\*.*?\*/', '', normalized_content_str[header_match.end():])
            # Combine the header with the cleaned content
            final_content = header + content_without_inline_comments
        else:
            final_content = normalized_content_str  # No header found, keep original content

        # Update the hash
        sha256_hash.update(final_content.encode('utf-8'))

    return sha256_hash.hexdigest()


# Function to extract and concatenate strings from table.concat, and print the line
def extract_and_concat_table_concat(content, file_path):
    lines = content.splitlines()  
    for line_num, line in enumerate(lines, start=1):
        matches = re.findall(table_concat_pattern, line, re.IGNORECASE)
        for match in matches:
            elements = match.replace("'", "").split(", ")
            concatenated_string = ''.join(elements)
            print(f"Concatenated table.concat result: {concatenated_string} (found in {file_path} at line {line_num})")
            print(f"Line-{line_num}: {line.strip()[:130]}...")  # Print only the first 130 characters of the found line

def search_for_malware(directory):
    print(Fore.GREEN + f"Searching directory: {directory}")
    print(Fore.MAGENTA + f"Excluding folders: {', '.join(excluded_folders)}")
    print(Fore.MAGENTA + f"Excluding extensions: {', '.join(excluded_extensions)}")

    files_scanned = 0  #file scan counter
    scanned_files = []

    for root, dirs, files in os.walk(directory):
        # Exclude specific directories
        dirs[:] = [d for d in dirs if d not in excluded_folders]

        for file in files:
            # Skip files with excluded extensions
            file_path = os.path.join(root, file)
            if any(file.endswith(ext) for ext in excluded_extensions) or file in whitelisted_files:
                continue

            if file_path in whitelisted_paths:
                file_hash = get_file_hash(file_path)
                if whitelisted_paths[file_path] == file_hash:
                    print(Fore.GREEN + f"Skipping whitelisted file: {file_path}")
                    continue

            scanned_files.append(file_path)

            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read()
                
                files_scanned += 1

                # Search using regex for hex escape sequences
                for line_num, line in enumerate(file_content.splitlines(), start=1):
                    # Skip lines with whitelisted patterns
                    if any(re.search(pattern, line) for pattern in whitelisted_patterns):
                        continue

                    # Look for hex escape patterns with suspicious keywords
                    if re.search(hex_escape_pattern, line) and any(re.search(keyword, line) for keyword in suspicious_keywords):
                        print("=================================================================")
                        print(f"Suspicious hex pattern found in: {file_path} at line {line_num}")
                        print(f"Line-{line_num}: {line.strip()[:130]}...")

                extract_and_concat_table_concat(file_content, file_path)

                for pattern, description in lua_malware_patterns:
                    for line_num, line in enumerate(file_content.splitlines(), start=1):
                        if re.search(pattern, line, re.IGNORECASE):
                            print("=================================================================")
                            print(Fore.YELLOW + f"Malware pattern '{pattern}' found in: {file_path} at line {line_num}")
                            print(Fore.CYAN + f"Description: {description}")
                            print(Fore.RED + f"Line-{line_num}: {line.strip()[:130]}...")

                for pattern, description in specific_hex_patterns:
                    for line_num, line in enumerate(file_content.splitlines(), start=1):
                        if re.search(pattern, line, re.IGNORECASE):
                            print(Back.MAGENTA + f"=================================================================")
                            print(Back.MAGENTA + f"====================BELOW IS A 100% POSITIVE=====================")
                            print(Back.MAGENTA + f"=================================================================")
                            print(Fore.YELLOW + f"Specific hex pattern '{pattern}' found in: {file_path} at line {line_num}")
                            print(Fore.CYAN + f"Description: {description}")
                            print(Fore.RED + f"Line-{line_num}: {line.strip()[:130]}...")

                for pattern, description in string_patterns:
                    for line_num, line in enumerate(file_content.splitlines(), start=1):
                        line_lower = line.lower()  
                        if pattern.lower() in line_lower: 
                            print(Back.MAGENTA + f"=================================================================")
                            print(Back.MAGENTA + f"====================BELOW IS A 100% POSITIVE=====================")
                            print(Back.MAGENTA + f"=================================================================")
                            print(Fore.YELLOW + f"Malware string pattern found in: {file_path} at line {line_num}")
                            print(Fore.CYAN + f"Description: {description}")
                            print(Fore.RED + f"Line-{line_num}: {line.strip()[:130]}...")
            except (UnicodeDecodeError, OSError):
                # Skip binary files or unreadable files
                continue

    print(Fore.WHITE + Back.GREEN +"=================================================================")
    print(Fore.WHITE + Back.GREEN +f"Scan complete. Total files scanned: {files_scanned}  ")
    print(Fore.WHITE + Back.GREEN +"=================================================================")

    # Ask if the user wants to print the path of all files scanned
    user_choice = input(Fore.CYAN + "Do you want to view the path of all files scanned? (y/n): ").strip().lower()
    if user_choice == 'y':
        print(Fore.YELLOW + "=================================================================")
        print(Fore.YELLOW + "List of all files scanned:")
        for path in scanned_files:
            print(Fore.WHITE + f"Scanned file: {path}")
        print(Fore.YELLOW + "=================================================================")

    # Ask if the user wants to scan .js files
    print(Fore.WHITE + Style.BRIGHT + Back.RED + "WARNING: JavaScript (.js) files can contain malicious code. It is highly recommended to proceed with the scan to ensure safety.")
    response = input(Fore.CYAN + "Do you want to scan JavaScript (.js) files for malicious patterns? (y/n): ").strip().lower()
    if response == 'y':
        search_for_js_malware(directory, whitelisted_js_hashes)


# Function to search JavaScript files for malware
def search_for_js_malware(directory, whitelist):
    print(Fore.GREEN + f"Scanning JavaScript files in: {directory}")
    files_scanned = 0
    scanned_files = []  # List to store paths of all .js files scanned

    for root, dirs, files in os.walk(directory):
        dirs[:] = [d for d in dirs if d not in excluded_folders]

        for file in files:
            if file.endswith('.js'):  # Only scan .js files
                file_path = os.path.join(root, file)
                

                # Get file hash and skip if it's in the whitelist (regardless of filename)
                file_hash = get_file_hash(file_path)
                if file_hash in whitelist:
                    print(Fore.GREEN + f"[+] =========================================================")
                    print(Fore.GREEN + f"[+] Skipping whitelisted file by hash (safe content): {file} ")
                    print(Fore.GREEN + f"[+] =========================================================")
                    continue


                # Only append to scanned files if the file is not in the whitelist
                scanned_files.append(file_path)  # Add to scanned files list
                
                files_scanned += 1
                is_malicious = False  # Flag to check if the file is malicious

                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        file_content = f.read()

                    for pattern, description in js_malware_patterns:
                        for line_num, line in enumerate(file_content.splitlines(), start=1):
                            if re.search(pattern, line, re.IGNORECASE):
                                print("=================================================================")
                                print(Fore.YELLOW + f"JavaScript malware pattern '{pattern}' found in: {file_path} at line-{line_num}")
                                print(Fore.CYAN + f"Description: {description}")
                                print(Fore.RED + f"Line-{line_num}: {line.strip()[:130]}...")
                                is_malicious = True 

                except (UnicodeDecodeError, OSError):
                    # Skip binary files or unreadable files
                    continue

                # If the file was detected as malicious, call the check_and_replace function
                if is_malicious:
                    # Call check_and_replace first to see if the file is found
                    if not check_and_replace(file_path):  # Assuming check_and_replace returns a boolean
                        user_response = input(Fore.CYAN + f"Do you want to open {file} in VS Code to inspect it? (y/n): ").strip().lower()
                        if user_response == 'y':
                            try:
                                # Construct the path to the VS Code executable
                                vscode_path = os.path.join(os.path.expanduser('~'), 'AppData', 'Local', 'Programs', 'Microsoft VS Code', 'code')
                                subprocess.run([vscode_path, file_path])
                                time.sleep(20)  # Wait for 20 seconds
                                
                                # Ask if the file is safe after viewing
                                safe_response = input(Fore.CYAN + f"Is this file safe? " + Fore.RED + f"{file_path}" + Fore.RESET + "(y/n): ").strip().lower()
                                if safe_response == 'n':
                                    print(Fore.RED + "The file is flagged as unsafe.")
                                    # Additional handling if needed
                                else:
                                    handle_safe_file(file_path)
                            except FileNotFoundError as e:
                                print(Fore.RED + f"Error: {e}. Please ensure that Visual Studio Code is installed at the expected location.")
                            except Exception as ex:
                                print(Fore.RED + f"An unexpected error occurred: {ex}")

    print(Fore.WHITE + Back.GREEN + "=================================================================")
    print(Fore.WHITE + Back.GREEN + f"JavaScript scan complete. Total .js files scanned: {files_scanned}  ")
    print(Fore.WHITE + Back.GREEN + "=================================================================")

    # Ask user if they want to print paths of scanned files
    user_choice = input(Fore.CYAN + "Do you want to view the path of all .js files scanned? (y/n): ").strip().lower()
    if user_choice == 'y':
        print(Fore.YELLOW + "=================================================================")
        print(Fore.YELLOW + "List of all .js files scanned:")
        for path in scanned_files:
            print(Fore.WHITE + f"Scanned file: {path}")
        print(Fore.YELLOW + "=================================================================")

if __name__ == "__main__":
    if len(sys.argv) > 1:
        search_directory = sys.argv[1]
    else:
        root = Tk()
        root.withdraw() 
        search_directory = filedialog.askdirectory(title="Select Directory to Scan")

        if not search_directory:
            print(Fore.RED + "No directory selected. Exiting...")
            sys.exit(1)


    # Load the whitelist from a CSV file
    whitelist_csv_file = 'whitelisted_js_files.csv'  # Define your CSV filename
    whitelisted_js_hashes = load_whitelist_from_csv(whitelist_csv_file)

    if whitelisted_js_hashes:
        print (Fore.GREEN + ".js whitelist loaded.")
        search_for_malware(search_directory)
    else:
        print(Fore.RED + "No whitelist loaded. Exiting...")
        exit
